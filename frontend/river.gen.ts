/**********************************************************************
/ Generated by tsgen. DO NOT EDIT.
/*********************************************************************/

/**********************************************************************
/ Collection:
/*********************************************************************/

const routes = [
	{
		_type: "loader",
		params: [],
		pattern: "/_index",
		phantomOutputType: null as unknown as RootData,
	},
] as const;

/**********************************************************************
/ Ad Hoc Types:
/*********************************************************************/

export type RootData = {
	Message: string;
};

/**********************************************************************
/ Extra TS Code:
/*********************************************************************/

export type RiverLoader = Extract<(typeof routes)[number], { _type: "loader" }>;
export type RiverLoaders = { [K in RiverLoaderPattern]: Extract<RiverLoader, { pattern: K }>; };
export type RiverLoaderPattern = RiverLoader["pattern"];
export type RiverLoaderOutput<T extends RiverLoaderPattern> = Extract<RiverLoader, { pattern: T }>["phantomOutputType"];

export type RiverQuery = Extract<(typeof routes)[number], { _type: "query" }>;
export type RiverQueries = { [K in RiverQueryPattern]: Extract<RiverQuery, { pattern: K }>; };
export type RiverQueryPattern = RiverQuery["pattern"];
export type RiverQueryInput<T extends RiverQueryPattern> = Extract<RiverQuery, { pattern: T }>["phantomInputType"];
export type RiverQueryOutput<T extends RiverQueryPattern> = Extract<RiverQuery, { pattern: T }>["phantomOutputType"];

export type RiverMutation = Extract<(typeof routes)[number], { _type: "mutation" }>;
export type RiverMutations = { [K in RiverMutationPattern]: Extract<RiverMutation, { pattern: K }>; };
export type RiverMutationPattern = RiverMutation["pattern"];
export type RiverMutationInput<T extends RiverMutationPattern> = Extract<RiverMutation, { pattern: T }>["phantomInputType"];
export type RiverMutationOutput<T extends RiverMutationPattern> = Extract<RiverMutation, { pattern: T }>["phantomOutputType"];
export type RiverMutationMethod<T extends RiverMutationPattern> = Extract<
	RiverMutation,
	{ pattern: T }
> extends { method: infer M }
	? M extends string
		? M
		: "POST"
	: "POST";

import type { SharedBase } from "river.now/client";

export type BaseQueryProps<P extends RiverQueryPattern> = SharedBase<P>;
export type BaseMutationProps<P extends RiverMutationPattern> = SharedBase<P> &
	(RiverMutationMethod<P> extends "POST"
		? { method?: "POST" }
		: { method: RiverMutationMethod<P> });
export type BaseQueryPropsWithInput<P extends RiverQueryPattern> = BaseQueryProps<P> & {
	input: RiverQueryInput<P>;
};
export type BaseMutationPropsWithInput<P extends RiverMutationPattern> = BaseMutationProps<P> & {
	input: RiverMutationInput<P>;
};
export type RiverRootData = null;
type RiverFunction = RiverLoader | RiverQuery | RiverMutation;
type RiverPattern = RiverLoaderPattern | RiverQueryPattern | RiverMutationPattern;
export type RiverRouteParams<T extends RiverPattern> = (Extract<RiverFunction, { pattern: T }>["params"])[number];

export const ACTIONS_ROUTER_MOUNT_ROOT = "/api/";

/**********************************************************************
/ River Vite Plugin:
/*********************************************************************/

import type { Plugin } from "vite";

const rollupOptions = {
	input: [
		"frontend/entry.tsx",
		"frontend/home.tsx",
	] as string[],
	preserveEntrySignatures: "exports-only",
	output: {
		assetFileNames: "river_out_vite_[name]-[hash][extname]",
		chunkFileNames: "river_out_vite_[name]-[hash].js",
		entryFileNames: "river_out_vite_[name]-[hash].js",
	},
} as const;

export const staticPublicAssetMap = {} as const;

export type StaticPublicAsset = keyof typeof staticPublicAssetMap;

declare global {
	function getPublicURLBuildtime(staticPublicAsset: StaticPublicAsset): string;
}

export const publicPathPrefix = "/public/";

export function waveRuntimeURL(originalPublicURL: keyof typeof staticPublicAssetMap) {
	const url = staticPublicAssetMap[originalPublicURL] ?? originalPublicURL;
	return publicPathPrefix + url;
}

export function riverVitePlugin(): Plugin {
	return {
		name: "river-vite-plugin",
		config(c, { command }) {
			const mp = c.build?.modulePreload;
			const roi = c.build?.rollupOptions?.input;
			const ign = c.server?.watch?.ignored;
			const dedupe = c.resolve?.dedupe;

			const isDev = command === "serve";

			return {
				...c,
				base: isDev ? "/" : "/public/",
				build: {
					target: "es2022",
					...c.build,
					emptyOutDir: false,
					modulePreload: { 
						polyfill: false,
						...(typeof mp === "object" ? mp : {}),
					},
					rollupOptions: {
						...c.build?.rollupOptions,
						...rollupOptions,
						input: [
							...rollupOptions.input,
							...(Array.isArray(roi) ? roi : []),
						],
					},
				},
				server: {
					...c.server,
					headers: {
						...c.server?.headers,
						// ensure versions of dynamic imports without the latest
						// hmr updates are not cached by the browser during dev
						"cache-control": "no-store",
					},
					watch: {
						...c.server?.watch,
						ignored: [
							...(Array.isArray(ign) ? ign : []),
							...[
								"**/*.go",
								"**/app/__dist/**/*",
								"**/backend/__static/**/*",
								"**/wave.config.json",
								"**/frontend/river.gen.ts",
								"**/frontend/routes.ts"
							],
						],
					},
				},
				resolve: {
					...c.resolve,
					dedupe: [
						...(Array.isArray(dedupe) ? dedupe : []),
						...["react","react-dom"]
					],
				},
			};
		},
		transform(code, id) {
			const isNodeModules = /node_modules/.test(id);
			if (isNodeModules) return null;
			const assetRegex = /getPublicURLBuildtime\s*\(\s*(["'`])(.*?)\1\s*\)/g;
			const needsReplacement = assetRegex.test(code);
			if (!needsReplacement) return null;
			const replacedCode = code.replace(
				assetRegex,
				(_, __, assetPath) => {
					const hashed = (staticPublicAssetMap as Record<string, string>)[assetPath];
					if (!hashed) return `"${assetPath}"`;
					return `"/public/${hashed}"`;
				},
			);
			if (replacedCode === code) return null;
			return replacedCode;
		},
	};
}
